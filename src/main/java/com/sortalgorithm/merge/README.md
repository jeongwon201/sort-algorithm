# Merge Sort, 합병(병합) 정렬

**합병 정렬**이란, 분할 정복 알고리즘으로 정렬하는 기법이다.   
<br />

> **분할 정복 알고리즘이란?**   
> 해결할 수 없는 문제를 작은 문제로 분할하여 해결하는 알고리즘을 말한다.   
> 분할 정복 알고리즘은 보통 재귀 함수를 통해 자연스럽게 구현된다.

구체적으로 설명하면, 리스트를 잘게 쪼개어 생성된 부분 리스트에서   
인접한 원소를 비교하여 정렬하면서 리스트를 합쳐나가는 방식이다.   
<br />

## 알고리즘
> 모든 알고리즘은 오름차순을 기준으로 설명합니다.

<br />

합병 정렬의 전체적인 과정은 다음과 같다.
<br />
<br />

<div align="center">
    <img src="img/img.png" width="700px" />
    <br />
</div>
<br />
<br />

먼저 정렬할 리스트를 잘게 쪼갠다.
<br />

리스트를 잘게 쪼개어 여러 부분 리스트가 되었다면,   
다음은 부분 리스트를 서로 비교하면서 오름차순 기준 작은 값 부터 하나씩 합쳐나간다.
<br />

이 때 중요한 부분이 **작은 값 부터 하나씩 합쳐나간다**는 부분이다.   
두 리스트를 이어 하나의 리스트로 합친 후 정렬을 하는 것이 아닌, 정렬을 하면서 합병한다.
<br />

합병 과정은 다음과 같다.
<br />
<br />

<div align="center">
    <img src="img/img_1.png" width="700px" />
    <br />
</div>
<br />
<br />

부분 리스트의 가장 앞 원소부터 하나씩 비교하면서 리스트를 채워나가는 방식이다.
<br />
<br />

위에서 설명한 합병 정렬처럼   
리스트를 더 이상 나눌 수 없을 때 까지 두 개로 쪼개어 합병하는 방식을,   
**2-way 합병 정렬**이라고 부른다.
<br />

합병 정렬이 보통 재귀 함수로 자연스럽게 구현되는 분할 정복 알고리즘에 기반하기 때문에, 재귀 함수로 구현할 수 있다.   
그러나 정렬 알고리즘에서는 성능을 위해 재귀 함수를 사용하지 않는다.   
<br />

코드에서는 재귀 함수를 이용한 방식과 재귀 함수를 이용하지 않는 방식을 모두 구현한다.
<br />
<br />
<br />
<br />

## 시간 복잡도
합병 정렬의 시간 복잡도는 다음과 같다.
> 모든 경우에서 **O(NlogN)**

<br />
<br />

시간복잡도가 **O(NlogN)** 인 이유는 다음과 같다.   
리스트를 1 개 까지 쪼개어 보면 이진 트리의 구조를 가진다.   
n개의 노드에 대한 이진 트리의 높이는 O(logN)이며, 합병 과정에서는 O(N) 만큼의 시간이 소요된다.   
이진 트리의 높이 만큼 합병이 수행되므로 O(logN) * O(N) = O(logN * N) = **O(NlogN)**
<br />
<br />
<br />
<br />

## 특징
합병 정렬은 데이터를 비교하면서 정렬하기 때문에 **비교 정렬**이며,   
정렬 대상 외 추가적인 공간을 필요로 하기 때문에 **제자리 정렬** 아니다.   
리스트을 그대로 분할하며 정렬하기 때문에 **안정 정렬**이다.   
<br />

> - **비교 정렬**
> - **안정 정렬**

<br />
 
정렬 과정에서 추가적인 공간을 필요로 하기 때문에 메모리 사용량이 많다.   
보조 배열에서 원본 배열로 복사하는 과정에서 많은 시간을 소비하기에,   
데이터가 많을 경우 시간이 많이 소요된다.