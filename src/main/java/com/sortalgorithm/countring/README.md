# Counting Sort, 카운팅 정렬

**카운팅 정렬** 또는 **계수 정렬** 이란,   
정수 정렬 알고리즘의 하나로, 구별되는 키 값들을 소유하는 객체의 수를 계수(count)하고,   
출력 시퀀스에 각 키 값의 위치를 결정하기 위한 해당 계수에 전위 합을 적용함으로써 동작한다.   
<br />
<br />
<br />
<br />

## 알고리즘
> 모든 알고리즘은 오름차순을 기준으로 설명합니다.

<br />

<iframe width="1280" height="720" src="https://www.youtube.com/embed/7zuGmKfUt7s" title="Counting Sort | GeeksforGeeks" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<br />

**[0:19 ~ 0:23]**   
입력 배열이 있을 때, 배열의 요소 중 **가장 큰 값 + 1** 의 길이를 가지는 카운팅 배열을 생성한다.   
<br />

**[0:23 ~ 0:43]**   
입력 배열의 요소를 계수(count)하여 카운팅 배열의 인덱스에 배치한다.
<br />

**[0:43 ~ 1:15]**   
카운팅 배열의 요소에 직전 요소의 값을 더한다.   
앞서 카운팅 배열에 대한 설명 중 **전위 합**에 해당하는 작업이다.
<br />

**[1:15 ~ 1:57]**   
입력 배열과 같은 길이의 출력 배열을 생성한다.   
입력 배열의 요소를 출력 배열에 배치한다.
<br />

입력 배열의 요소를 출력 배열의 어느 인덱스에 배치할 것인가는 다음 규칙을 통해 확인할 수 있다.
- 입력 배열의 값은 카운팅 배열의 인덱스를 가리킨다.
- 카운팅 배열의 값은 출력 배열의 인덱스를 가리킨다.

입력 배열의 요소를 출력 배열에 배치할 때, 카운팅 배열의 값을 1씩 감소시킨다.
<br />
<br />
<br />
<br />

## 시간 복잡도
카운팅 정렬의 시간 복잡도는 다음과 같다.
> 모든 경우에서 **O(n + k)**

카운팅 정렬은 입력 배열을 3 번 순회한다.
 - 카운팅 배열 생성을 위해 최대 값을 찾기 위한 순회
 - 입력 배열의 요소를 계수하기 위한 순회
 - 입력 배열을 출력 배열에 배치하기 위한 순회

이 순회는 모두 배열을 1번 순회하므로, 시간 복잡도는 **O(n)** 이다.
<br />

그러나 배열의 길이에 상관없이 배열의 최댓값 K가 정렬 시간의 변수로 작용한다.   
<br />

예를 들어 배열의 길이는 작은데 최댓값이 매우 클 경우,   
카운팅 배열의 길이 또한 증가하여, 정렬 시간은 그만큼 길어진다.   
<br />

이는 시간 복잡도가 배열의 최댓값 K에 종속된다는 것을 의미한다.   
그러므로 일반적으로 카운팅 정렬의 시간 복잡도는 **O(n + k)** 라고 말한다.
<br />
<br />
<br />
<br />

## 특징
카운팅 정렬은 데이터를 비교하지 않고, 특정 기준에 따라 정렬하기 때문에 **비교 정렬**이 아니며,   
정렬 대상 외 추가로 카운팅 배열을 생성하기 때문에 **제자리 정렬**또한 아니다.   
<br />

카운팅 정렬은 카운팅 배열에서 출력 배열로 데이터를 배치할 때,   
오른쪽에서 왼쪽으로 배치하면 **안정 정렬**의 조건을 만족한다.
<br />

> - **안정 정렬**